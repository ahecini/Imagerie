
// =====================================================
// PLAN 3D, Support géométrique
// =====================================================

shaders['textures'] = {
vert:`#version 300 es
//================================================================
layout(location = 0) in vec2 aVpos;

uniform mat4 uPMatrix;
uniform mat4 uMVMatrix;

out vec2 pos;

void main(void) {
    pos=aVpos;
    gl_Position = uPMatrix * uMVMatrix * vec4(aVpos*1.9-0.95, 0.0, 1.0);
}
//================================================================`
,

frag:`#version 300 es
//================================================================

precision mediump float;
in vec2 pos;
out vec4 FragColor;
vec2 iResolution = vec2(512, 512);
float iTime = 0.0001;


//VERSIONS Improved 2D fast perlin noise

//hash function that returns a gradient direction based on the hash value
vec2 hash2(vec2 p) {
    p = vec2(dot(p, vec2(127.1, 311.7)),
             dot(p, vec2(269.5, 183.3)));    //mélanger les coordonnées pour éviter les motifs répétitifs
	vec2 h = fract(sin(p) * 43758.5453123);      //produit des valeurs pseudos aléatoires
    return -1.0 + 2.0 * h; // normaliser entre -1 et 1
}

float interpolate(float value1, float value2, float value3, float value4, vec2 t) {
    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);
}

float interpolate2(float x, float a, float b) {
    return (1.0 - x) * a + x * b;
}

vec2 fade(vec2 t) {
    // 6t^5 - 15t^4 + 10t^3
	return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

float perlinNoise(vec2 position) {
    vec2 floorPosition = floor(position);
    vec2 fractPosition = position - floorPosition;
    //uvec2 cellCoordinates = uvec2(floorPosition);

    //Calcul du produit scalaire entre le gradient et le vecteur de distance
    float value1 = dot(hash2(floorPosition), fractPosition);
    float value2 = dot(hash2(floorPosition + vec2(1, 0)), fractPosition - vec2(1.0, 0.0));
    float value3 = dot(hash2(floorPosition + vec2(0, 1)), fractPosition - vec2(0.0, 1.0));
    float value4 = dot(hash2(floorPosition + vec2(1, 1)), fractPosition - vec2(1.0, 1.0));
    return interpolate(value1, value2, value3, value4, fade(fractPosition));
}

float perlinNoise(vec2 position, int frequency, int octaveCount, float persistence, float lacunarity) {
    float value = 0.0;
    float amplitude = 1.0;
    float currentFrequency = float(frequency);
    float maxAmplitude = 0.0;
    //uint currentSeed = seed;
    for (int i = 0; i < octaveCount; i++) {
        //currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave
        value += perlinNoise(position * currentFrequency) * amplitude;
        amplitude *= persistence;
        currentFrequency *= lacunarity;
        maxAmplitude += amplitude;
    }
    return value/maxAmplitude; // normaliser le résultat final
}

// -------------------- TURBULANCE ----------------
float turbulence(vec2 position, float frequency){
	float value = 0.0, size = frequency;
	while(size >= 1.0){
		value += perlinNoise(position/size, 1, 6, 0.5, 2.0);
		size /= 2.0;
	}
	return (value / frequency);
}

// ---------------- DISTANCE ENTRE LE CENTRE DU QUADRE ET LES PIXEL -------
float distanc (vec2 position, float frequence){
	float centre = frequence / 2.0;
	float dist = sqrt(pow((position.x-centre), 2.0) + pow((position.y - centre),2.0));
	return dist;
}

// ----------------DISTANCE ENTRE LA MEDIANE DU CARREE ET UN POINT QLQ ----------
bool distMediane(float position, float frequence){
	float centre = frequence / 2.0;
	float riv = frequence / 4.0;
	float dist = abs(position - centre);
	if(dist >= riv) return true;
	else return false;
}

// ----------------- DEFORMATION --------------
float riverOffset(float y) {
    float sinWave = sin(y * 0.1) * 5.0;
    float noise = perlinNoise(vec2(y * 0.05, 0.0)) * 5.0;
    return sinWave + noise;
}

void main() {
	float frequence = 64.0;
    vec2 position = pos*frequence;

	float centre = frequence / 2.0;
	float riv = frequence / 4.0;
	float offset = riverOffset(position.y);
	float dist = abs(position.x - (centre + offset));

   vec2 uv = pos * frequence;

	vec2 ij = floor(uv);
	float a = perlinNoise(ij);
	float b = perlinNoise(ij + vec2(1, 0));
	float c = perlinNoise(ij + vec2(0, 1));
	float d = perlinNoise(ij + vec2(1, 1));

	float posLocalX = uv.x - ij.x;
	float posLocalY = uv.y - ij.y;

	float v1 = interpolate2(posLocalX, a, b);
	float v2 = interpolate2(posLocalX, c, d);
	float val = interpolate2(posLocalY, v1, v2);

	vec3 color;
	if(dist >= riv) {
		// forêt
		color = mix(vec3(0.0, 0.5, 0.0), vec3(0.0, 0.9, 0.2), perlinNoise(position, 1, 6, 0.5, val)); // Côte
	} else {
		// rivière
		val = (position.y + turbulence(position, frequence))*0.5 + 0.5;
	 	color = mix(vec3(0.0, 0.5, 1.0), vec3(0.0, 0.8, 0.8), perlinNoise(position, 5, 1, 0.5, val)); 
	}
		FragColor = vec4(vec3(color), 1.0);
	}
//================================================================`

};




class textures {

	// --------------------------------------------
	constructor() {
		this.ready = false;
		this.shaderParams = {};
		this.shader=null;
		this.vsTxt = shaders['textures'].vert;
		this.fsTxt = shaders['textures'].frag;

		compileShaders(this);

      this.initAll();
	}

	// --------------------------------------------
	initAll() {
		var vertices = [0,0,  1,0,  1,1,  0,1];
		gl.useProgram(this.shader);
		this.vBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

		this.shaderParams.vAttrib = gl.getAttribLocation(this.shader, "aVpos");
		this.shaderParams.pMatrixUniform = gl.getUniformLocation(this.shader, "uPMatrix");
		this.shaderParams.mvMatrixUniform = gl.getUniformLocation(this.shader, "uMVMatrix");
        //this.shaderParams.iTime = gl.getUniformLocation(this.shader, "iTime");

		this.vBuffer.itemSize = 2;
		this.vBuffer.numItems = 4;
	   this.ready=true;
	}

	// --------------------------------------------
	setShadersParams() {

		mat4.perspective(45, gl.width / gl.height, 0.1, 100.0, pMatrix);
		mat4.identity(mvMatrix);
		mat4.translate(mvMatrix, [trX, trY, renderData.dist]);
		mat4.multiply(mvMatrix, rotMatrix);
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vBuffer);

		gl.vertexAttribPointer(this.shaderParams.vAttrib, this.vBuffer.itemSize, gl.FLOAT, false, 0, 0);
		gl.enableVertexAttribArray(this.shaderParams.vAttrib);

		gl.uniformMatrix4fv(this.shaderParams.pMatrixUniform, false, pMatrix);
		gl.uniformMatrix4fv(this.shaderParams.mvMatrixUniform, false, mvMatrix);
        

	}

	// --------------------------------------------
	draw() {
		if(this.ready) {

			gl.useProgram(this.shader);

			this.setShadersParams(); 
			gl.drawArrays(gl.TRIANGLE_FAN, 0, this.vBuffer.numItems); 

			gl.disableVertexAttribArray(this.shaderParams.vAttrib);
			gl.useProgram(null);
		}
	}
}










//
